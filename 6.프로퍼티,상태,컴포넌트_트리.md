## 프로퍼티, 상태, 컴포넌트 트리

### 1. 프로퍼티 검증

자바스크립트 타입 검증 느슨한 언어이다. <br />
따라서 변수의 데이터 값이 언제든 바뀔 수 있고, 그래도 자바스크립트에서는 아무런 문제가 없다.<br />
변수 타입을 비효율적으로 다루면 애플리케이션 디버깅할 때 시간이 아주 오래 걸릴 수 있다.<br />

리액트 컴포넌트는 프로퍼티 타입을 지정하고 검증하는 방법을 제공한다.<br />
이 기능을 사용하면 애플리케이션 디버깅 시간을 크게 줄일 수 있고, 프로퍼티에 잘못된 타입의 값을 지정하면 경고가 표시되기 떄문에 버그를 쉽게 찾을 수 있다.<br />

(프로퍼티 검증 ①필수 값 지정 ②프로퍼티 타입 검증 ③커스텀 프로퍼티 검증)

```javascript
// --save로 설치해야, 실행할 때도 프로퍼티를 검증한다.
npm install prop-types --save
```

| 타입      | 검증기                 |
| --------- | ---------------------- |
| Arrays    | React.PropTypes.array  |
| Boolean   | React.PropTypes.bool   |
| Functions | React.PropTypes.func   |
| Numbers   | React.PropTypes.number |
| Objects   | React.PropTypes.object |
| Strings   | React.PropTypes.string |

프로퍼티 검증을 구현하는 방법은 컴포넌트를 구현한 방법에 따라 달라진다.<br />
(컴포넌트 구현 방법 ①createClass ②ES6 Class ③상태가 없는 함수형 컴포넌트)



#### 1.1 createClass로 프로퍼티 검증하기

````jsx
const Summary = createClass({
    displayName: "Summary",
    render(){
        const {ingredients, steps, title} = this.props
        return(
            <div className="summary">
                <h1>{title}</h1>
                <p>
                    <span>재료 {ingredients.length} 종류 | </span>
                    <span>총 {steps.length} 단계</span>
                </p>
            </div>
        )
    }
})
/*
	Summay 컴포넌트는 프로퍼티 객체로부터 ingredients, steps, title을 구조 분해한 후,
	값을 표시하는 UI를 만든다.
	ingredients와 steps가 배열인 것을 알기에 Array.length를 사용했다.
*/
````

````jsx
// ingredients와 steps에 배열이 아닌 문자열을 넘긴다면 어떻게 될까?
const Summary = createClass({
    displayName: "Summary",
    render(){
        <Summary title="땅콘버터와 젤리" ingredients="땅콩버터, 젤리, 식빵" steps="땅콩버터와 젤리를 넓게 바른 식빵 두 장을 바른 면이 안으로 가도록 겹친다." />,
        document.getElementById('react-container')
    }
})
// 느슨한 자바스크립트는 문제점을 찾지 못하고 문자열의 length를 계산한다.
````

이런 버그가 생기지 않도록 컴포넌트를 만들 때 프로퍼티의 타입을 검증하는 것이 좋다.<br />

````jsx
const Summary = createClass({
    displayName: "Summary",
    
    // 프로퍼티 타입 검증
    propTypes: {
        ingredients: PropTypes.array,
        steps: PropTypes.array,
        title: PropTypes.string
    },
    //
    render(){
        const {ingredients, steps, title} = this.props
        return(
            <div className="summary">
                <h1>{title}</h1>
                <p>
                    <span>재료 {ingredients.length} 종류 | </span>
                    <span>총 {steps.length} 단계</span>
                </p>
            </div>
        )
    }
})
````

````jsx
// Summary 컴포넌트에 아무 프로퍼티도 넘기지 않으면 어떻게 될까?
const Summary = createClass({
    displayName: "Summary",
    render(){
        <Summary />,
        document.getElementById('react-container')
    }
})
// 프로퍼티를 지정하지 않고 Summary를 렌더링하면 콘솔 창에 undefined 오류가 발생한다.
// undefined는 배열이나 문자열처럼 length 프로퍼티를 가지고 있는 객체가 아니기 때문에 오류가 발생한다.
````

이런 오류가 생기지 않도록 리액트는 필수 프로퍼티를 지정하는 방법을 제공한다.<br />

필수 프로퍼티를 지정하지 않으면 콘솔에 경고가 뜬다.<br />

````jsx
const Summary = createClass({
    displayName: "Summary",
    
    // 프로퍼티 타입 검증 + 필수 프로퍼티 지정(.isRequired)
    propTypes: {
        ingredients: PropTypes.array.isRequired,
        steps: PropTypes.array.isRequired,
        title: PropTypes.string
    },
    //
    render(){
        const {ingredients, steps, title} = this.props
        return(
            <div className="summary">
                <h1>{title}</h1>
                <p>
                    <span>재료 {ingredients.length} 종류 | </span>
                    <span>총 {steps.length} 단계</span>
                </p>
            </div>
        )
    }
})
````



#### 1.2 디폴트 프로퍼티

프로퍼티 값을 지정하지 않을 경우, 디폴트로 지정한 값을 사용할 수 있다.<br />

createClass를 <u>사용하면 설정되지 않은 프로퍼티에 대한 디폴트 값을 반환하는 메서드</u>로 getDefaultProps를 추가할 수 있다.

````jsx
const Summary = createClass({
    displayName: "Summary",
    
    // 프로퍼티 타입 검증 + 필수 프로퍼티 지정(.isRequired)
    propTypes: {
        ingredients: PropTypes.number,
        steps: PropTypes.number,
        title: PropTypes.string
    },
    // 디폴트 프로퍼티 설정
    getDefaultProps(){
        return{
            ingredients: 0,
            steps: 0,
            title: "[무제]"
        }
    },//
    render(){
        const {ingredients, steps, title} = this.props
        return(
            <div className="summary">
                <h1>{title}</h1>
                <p>
                    <span>재료 {ingredients} 종류 | </span>
                    <span>총 {steps} 단계</span>
                </p>
            </div>
        )
    }
})
````



#### 1.3 커스텀 프로퍼티 검증

커스텀 검증기는 함수로 구현된다.<br />

커스텀 검증기를 사용하면 원하는 검증 기준을 구체적으로 구현할 수 있다.

* 검증 요구사항에 만족 => null 반환
* 검증 요구사항에 불만족 => 에러 반환

````jsx
// ex) 프로퍼티가 문자열인지 검사 후, 문자열 길이가 20자 초과하는지 검사
// test ? expression1 : expression2
// 삼항연산자 test가 true면 expression1 반환. false면 expression2 반환
const Summary = createClass({
    displayName: "Summary",
    
    // 기본 프로퍼티 타입 검증 + 커스텀 프로퍼티 검증
    propTypes: {
        ingredients: PropTypes.number,
        steps: PropTypes.number,
        // title 프로퍼티를 콜백 함수로 설정
        title: (props, propName) => 
        	(typeof props[propName] !== 'string') ?		// string 아닌지(!==) 검사
        	new Error("제목(title)은 문자열이어야 합니다.") : 	// 아니면 Error메시지 반환
        	(props[propName].length > 20) ? 	// 맞다면, 20글자 이내인지 검사
        	new Error("제목은 20자 이내여야 합니다.") : 	// 20글자보다 크다면 Error메시지 반환
        	null 	// 20글보다 작다면 null 반환
    },
    // 디폴트 프로퍼티 설정
    getDefaultProps(){
        ...
    },//
    render(){
        ...
    }
})
// 컴포넌트를 렌더링할 때 리액트는 이 함수에 props 프로퍼티 객체와 프로퍼티 이름을 인자로 넘긴다.
````



#### 1.4 ES6 클래스와 상태가 없는 함수형 컴포넌트

````jsx
// ES6 클래스 사용시 propTypes와 defaultProps 선언
class Summary extends React.Component {
    render(){
        const {ingredients, steps, title} = this.props
        return(
            <div className="summary">
                <h1>{title}</h1>
                <p>
                    <span>재료 {ingredients} 종류 | </span>
                    <span>총 {steps} 단계</span>
                </p>
            </div>
        )
    }
}
Summary.propTypes = {
    ingredients: PropTypes.number,
    steps: PropTypes.number,
    title: (props, propName) => 
    	(typeof props[propName] !== 'string') ?
    	new Error("제목(title)은 문자열이어야 합니다.") :
    	(props[propName].length > 20) ?
    	new Error("제목은 20자 이내여야 합니다.") :
    	null
}
Summary.getDefaultProps = {
    ingredients: 0,
    steps: 0,
    title: "[무제]"
}
````

````jsx
// 상태가 없는 함수형 컴포넌트
const Summary = ({ingredients, steps, title}) => {
    return(
        <div className="summary">
            <h1>{title}</h1>
            <p>
                <span>재료 {ingredients} 종류 | </span>
                <span>총 {steps} 단계</span>
            </p>
        </div>
    )
}
Summary.propTypes = {
    ingredients: PropTypes.number,
    steps: PropTypes.number,
    title: (props, propName) => 
    	(typeof props[propName] !== 'string') ?
    	new Error("제목(title)은 문자열이어야 합니다.") :
    	(props[propName].length > 20) ?
    	new Error("제목은 20자 이내여야 합니다.") :
    	null
}
Summary.getDefaultProps = {
    ingredients: 0,
    steps: 0,
    title: "[무제]"
}

// 상태가 없는 함수형 컴포넌트 => 디폴트 인자 지정 가능
const Summary = ({ingredients=0, steps=0, title=`[무제]`}) => {
    return(
        <div className="summary">
            <h1>{title}</h1>
            <p>
                <span>재료 {ingredients} 종류 | </span>
                <span>총 {steps} 단계</span>
            </p>
        </div>
    )
}
````

<u>최근 ECMAScript 명세로 제안 중인 **클래스의 정적 프로퍼티**</u>

클래스의 정적 프로퍼티를 사용하면 propTypes와 defaultProps를 클래스 선언 내부에 정의할 수 있다.<br />

=> 정적 프로퍼티 초기화를 활용하면 클래스를 더 캡슐화할 수 있고 코드도 더 깔끔해진다.

````jsx
// 클래스의 정적 프로퍼티
class Summary extends React.Component {
    static propTypes = {
        ingredients: PropTypes.number,
        steps: PropTypes.number,
        title: (props, propName) => 
            (typeof props[propName] !== 'string') ?
            new Error("제목(title)은 문자열이어야 합니다.") :
            (props[propName].length > 20) ?
            new Error("제목은 20자 이내여야 합니다.") :
            null
    }
    static getDefaultProps = {
        ingredients: 0,
        steps: 0,
        title: "[무제]"
    }
    render(){
        const {ingredients, steps, title} = this.props
        return(
            <div className="summary">
                <h1>{title}</h1>
                <p>
                    <span>재료 {ingredients} 종류 | </span>
                    <span>총 {steps} 단계</span>
                </p>
            </div>
        )
    }
}
````



### 2. 참조

#### 2.1 역방향 데이터 흐름

#### 2.2 상태가 없는 함수형 컴포넌트에서 참조 사용



### 3. 리액트 상태 관리

#### 3.1 컴포넌트 상태 소개

#### 3.2 프로퍼티로부터 상태 초기화하기



### 4. 컴포넌트 트리 안의 상태

#### 4.1 색 관리 앱 소개

#### 4.2 컴포넌트 트리 아래쪽으로 프로퍼티 전달하기

#### 4.3 컴포넌트 트리 위쪽으로 프로퍼티 전달하기

